<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>TensorFlow 2.0 | without_milk</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://j-j-b-b.github.io//favicon.ico?v=1652513807071">
<link rel="stylesheet" href="https://j-j-b-b.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="路线

ML的sklearn掌握
DL的tensorflow2.0掌握基本使用方法和调参方法（此时可以去试试行人识别）
RL的话，可以延续TF的学习路线，用TF-Agent表示代理，做简单的训练

资料
tensorflow
[toc]
初..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://j-j-b-b.github.io/">
        <img src="https://j-j-b-b.github.io//images/avatar.png?v=1652513807071" class="site-logo">
        <h1 class="site-title">without_milk</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/j-j-b-b" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com" target="_blank">GitHub pages</a> | <a class="rss" href="https://j-j-b-b.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">TensorFlow 2.0</h2>
            <div class="post-date">2022-05-14</div>
            
            <div class="post-content" v-pre>
              <p>路线</p>
<ol>
<li>ML的sklearn掌握</li>
<li>DL的tensorflow2.0掌握基本使用方法和调参方法（此时可以去试试行人识别）</li>
<li>RL的话，可以延续TF的学习路线，用TF-Agent表示代理，做简单的训练</li>
</ol>
<p>资料</p>
<p><a href="https://www.tensorflow.org/tutorials">tensorflow</a></p>
<p>[toc]</p>
<h1 id="初学者的-tensorflow-20-教程">初学者的 TensorFlow 2.0 教程</h1>
<p>下载并安装 TensorFlow 2.0 测试版包。将 TensorFlow 载入你的程序：</p>
<pre><code class="language-python"># 安装TensorFlow
import tensorflow as tf
</code></pre>
<p>载入并准备好 <a href="http://yann.lecun.com/exdb/mnist/">MNIST 数据集</a>。将样本从整数转换为浮点数：</p>
<pre><code class="language-python">mnist = tf.keras.datasets.mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0 // 将样本从整数转换为浮点数
</code></pre>
<p>将模型的各层堆叠起来，以搭建 <code>tf.keras.Sequential</code> 模型。为训练选择优化器和损失函数：</p>
<pre><code class="language-python">model = tf.keras.models.Sequential([
	tf.keras.layers.Flatten(input_shape=(28, 28)),
	tf.keras.layers.Dense(128, activation='relu'),
	tf.keras.layers.Dropout(0.2),
	tf.keras.layers.Dense(10, activation='softmax')
])

model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])
</code></pre>
<p>训练并验证模型：</p>
<pre><code class="language-python">model.fit(x_train, y_train, epochs=5)

model.evaluate(x_test,  y_test, verbose=2)
</code></pre>
<blockquote>
<p>[0.07460852712392807, 0.9763000011444092]</p>
</blockquote>
<p>现在，这个照片分类器的准确度已经达到 98%。想要了解更多，请阅读 <a href="https://tensorflow.google.cn/tutorials/">TensorFlow 教程</a>。</p>
<h1 id="基本分类对服装图像进行分类">基本分类：对服装图像进行分类</h1>
<p>训练一个神经网络模型，对运动鞋和衬衫等服装图像进行分类。</p>
<p>使用了 <a href="https://tensorflow.google.cn/guide/keras">tf.keras</a>，它是 TensorFlow 中用来构建和训练模型的高级 API。</p>
<pre><code class="language-python"># TensorFlow and tf.keras
import tensorflow as tf
from tensorflow import keras

# Helper libraries
import numpy as np
import matplotlib.pyplot as plt

print(tf.__version__)
</code></pre>
<h2 id="导入-fashion-mnist-数据集">导入 Fashion MNIST 数据集</h2>
<p>使用 <a href="https://github.com/zalandoresearch/fashion-mnist">Fashion MNIST</a> 数据集，该数据集包含 10 个类别的 70,000 个灰度图像。这些图像以低分辨率（28x28 像素）展示了单件衣物。</p>
<p>使用 60,000 个图像来训练网络，使用 10,000 个图像来评估网络学习对图像分类的准确率。运行以下代码，直接从 TensorFlow 中导入和加载 Fashion MNIST 数据：</p>
<pre><code class="language-python">fashion_mnist = keras.datasets.fashion_mnist

(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data()
</code></pre>
<p>加载数据集会返回四个 NumPy 数组：</p>
<ul>
<li><code>train_images</code> 和 <code>train_labels</code> 数组是<em>训练集</em>，即模型用于学习的数据。</li>
<li><em>测试集</em>、<code>test_images</code> 和 <code>test_labels</code> 数组会被用来对模型进行测试。</li>
</ul>
<p>图像是 28x28 的 NumPy 数组，像素值介于 0 到 255 之间。<em>标签</em>是整数数组，介于 0 到 9 之间。</p>
<p>每个图像都会被映射到一个标签。由于数据集不包括<em>类名称</em>，请将它们存储在下方，供稍后绘制图像时使用：</p>
<pre><code class="language-python">class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat',
               'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']
</code></pre>
<h2 id="训练数据">训练数据</h2>
<pre><code class="language-python">train_images.shape
</code></pre>
<blockquote>
<p>(60000, 28, 28)</p>
</blockquote>
<p>同样，训练集中有 60,000 个标签：</p>
<pre><code class="language-python">len(train_labels)
</code></pre>
<blockquote>
<p>60000</p>
</blockquote>
<p>每个标签都是一个 0 到 9 之间的整数：</p>
<pre><code class="language-python">train_labels
</code></pre>
<blockquote>
<p>array([9, 0, 0, ..., 3, 0, 5], dtype=uint8)</p>
</blockquote>
<p>测试集中有 10,000 个图像。同样，每个图像都由 28x28 个像素表示：</p>
<pre><code class="language-python">test_images.shape
</code></pre>
<blockquote>
<p>(10000, 28, 28)</p>
</blockquote>
<p>测试集包含 10,000 个图像标签：</p>
<pre><code class="language-python">len(test_labels)
</code></pre>
<blockquote>
<p>10000</p>
</blockquote>
<h2 id="预处理数据">预处理数据</h2>
<p>在训练网络之前，必须对数据进行预处理。如果您检查训练集中的第一个图像，您会看到像素值处于 0 到 255 之间：</p>
<pre><code class="language-python">plt.figure()
plt.imshow(train_images[0])
plt.colorbar()
plt.grid(False)
plt.show()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://j-j-b-b.github.io//post-images/1652513662886.png" alt="" loading="lazy"></figure>
<p>将这些值缩小至 0 到 1 之间，然后将其馈送到神经网络模型。为此，请将这些值除以 255。请务必以相同的方式对<em>训练集</em>和<em>测试集</em>进行预处理：</p>
<pre><code class="language-python">train_images = train_images / 255.0

test_images = test_images / 255.0
</code></pre>
<p>为了验证数据的格式是否正确，以及您是否已准备好构建和训练网络，让我们显示<em>训练集</em>中的前 25 个图像，并在每个图像下方显示类名称。</p>
<pre><code class="language-python">plt.figure(figsize=(10,10))
for i in range(25):
    plt.subplot(5,5,i+1)
    plt.xticks([])
    plt.yticks([])
    plt.grid(False)
    plt.imshow(train_images[i], cmap=plt.cm.binary)
    plt.xlabel(class_names[train_labels[i]])
plt.show()
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://j-j-b-b.github.io//post-images/1652513671478.png" alt="" loading="lazy"></figure>
<h2 id="构建模型">构建模型</h2>
<p>构建神经网络需要先配置模型的层，然后再编译模型。</p>
<h3 id="设置层">设置层</h3>
<p>神经网络的基本组成部分是<em>层</em>。层会从向其馈送的数据中提取表示形式。希望这些表示形式有助于解决手头上的问题。</p>
<p>大多数深度学习都包括将简单的层链接在一起。大多数层（如 <code>tf.keras.layers.Dense</code>）都具有在训练期间才会学习的参数。</p>
<pre><code class="language-python">model = keras.Sequential([
    keras.layers.Flatten(input_shape=(28, 28)),
    keras.layers.Dense(128, activation='relu'),
    keras.layers.Dense(10)
])
</code></pre>
<p>该网络的第一层 <code>tf.keras.layers.Flatten</code> 将图像格式从二维数组（28 x 28 像素）转换成一维数组（28 x 28 = 784 像素）。将该层视为图像中未堆叠的像素行并将其排列起来。该层没有要学习的参数，它只会重新格式化数据。</p>
<p>展平像素后，网络会包括两个 <code>tf.keras.layers.Dense</code> 层的序列。它们是密集连接或全连接神经层。第一个 <code>Dense</code> 层有 128 个节点（或神经元）。第二个（也是最后一个）层会返回一个长度为 10 的 logits 数组。每个节点都包含一个得分，用来表示当前图像属于 10 个类中的哪一类。</p>
<h3 id="编译模型">编译模型</h3>
<p>在准备对模型进行训练之前，还需要再对其进行一些设置。以下内容是在模型的<em>编译</em>步骤中添加的：</p>
<ul>
<li><em>损失函数</em> - 用于测量模型在训练期间的准确率。您会希望最小化此函数，以便将模型“引导”到正确的方向上。</li>
<li><em>优化器</em> - 决定模型如何根据其看到的数据和自身的损失函数进行更新。</li>
<li><em>指标</em> - 用于监控训练和测试步骤。以下示例使用了<em>准确率</em>，即被正确分类的图像的比率。</li>
</ul>
<pre><code class="language-python">model.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])
</code></pre>
<h2 id="训练模型">训练模型</h2>
<p>训练神经网络模型需要执行以下步骤：</p>
<ol>
<li>将训练数据馈送给模型。在本例中，训练数据位于 <code>train_images</code> 和 <code>train_labels</code> 数组中。</li>
<li>模型学习将图像和标签关联起来。</li>
<li>要求模型对测试集（在本例中为 <code>test_images</code> 数组）进行预测。</li>
<li>验证预测是否与 <code>test_labels</code> 数组中的标签相匹配。</li>
</ol>
<h3 id="向模型馈送数据">向模型馈送数据</h3>
<p>要开始训练，请调用 <code>model.fit</code> 方法，这样命名是因为该方法会将模型与训练数据进行“拟合”：</p>
<pre><code class="language-python">model.fit(train_images, train_labels, epochs=10)
</code></pre>
<p>在模型训练期间，会显示损失和准确率指标。此模型在训练数据上的准确率达到了 0.91（或 91%）左右。</p>
<h3 id="评估准确率">评估准确率</h3>
<p>接下来，比较模型在测试数据集上的表现：</p>
<pre><code class="language-python">test_loss, test_acc = model.evaluate(test_images,  test_labels, verbose=2)

print('\nTest accuracy:', test_acc)
</code></pre>
<blockquote>
<p>Test accuracy: 0.8808000087738037</p>
</blockquote>
<p>结果表明，模型在测试数据集上的准确率略低于训练数据集。训练准确率和测试准确率之间的差距代表<em>过拟合</em>。过拟合是指机器学习模型在新的、以前未曾见过的输入上的表现不如在训练数据上的表现。过拟合的模型会“记住”训练数据集中的噪声和细节，从而对模型在新数据上的表现产生负面影响。有关更多信息，请参阅以下内容：</p>
<ul>
<li><a href="https://tensorflow.google.cn/tutorials/keras/overfit_and_underfit#demonstrate_overfitting">演示过拟合</a></li>
<li><a href="https://tensorflow.google.cn/tutorials/keras/overfit_and_underfit#strategies_to_prevent_overfitting">避免过拟合的策略</a></li>
</ul>
<h3 id="进行预测">进行预测</h3>
<p>在模型经过训练后，您可以使用它对一些图像进行预测。模型具有线性输出，即 <a href="https://developers.google.com/machine-learning/glossary#logits">logits</a>。您可以附加一个 softmax 层，将 logits 转换成更容易理解的概率。</p>
<pre><code class="language-python">probability_model = tf.keras.Sequential([model,tf.keras.layers.Softmax()])
</code></pre>
<pre><code class="language-python">predictions = probability_model.predict(test_images)
</code></pre>
<p>在上例中，模型预测了测试集中每个图像的标签。我们来看看第一个预测结果：</p>
<pre><code class="language-python">predictions[0]
</code></pre>
<blockquote>
<p>array([1.2416257e-06, 7.6264983e-10, 1.5464899e-08, 7.7544596e-11,       1.7675733e-07, 2.4696745e-02, 2.7702256e-08, 2.8554641e-02,       7.7712281e-09, 9.4674718e-01], dtype=float32)</p>
</blockquote>
<p>预测结果是一个包含 10 个数字的数组。它们代表模型对 10 种不同服装中每种服装的“置信度”。您可以看到哪个标签的置信度值最大：</p>
<pre><code class="language-python">np.argmax(predictions[0])
</code></pre>
<p>因此，该模型非常确信这个图像是短靴，或 <code>class_names[9]</code>。通过检查测试标签发现这个分类是正确的：</p>
<pre><code class="language-python">test_labels[0]
</code></pre>
<blockquote>
<p>9</p>
</blockquote>
<p>可以将其绘制成图表，看看模型对于全部 10 个类的预测。</p>
<pre><code class="language-python">def plot_image(i, predictions_array, true_label, img):
  predictions_array, true_label, img = predictions_array, true_label[i], img[i]
  plt.grid(False)
  plt.xticks([])
  plt.yticks([])

  plt.imshow(img, cmap=plt.cm.binary)

  predicted_label = np.argmax(predictions_array)
  if predicted_label == true_label:
    color = 'blue'
  else:
    color = 'red'

  plt.xlabel(&quot;{} {:2.0f}% ({})&quot;.format(class_names[predicted_label],
                                100*np.max(predictions_array),
                                class_names[true_label]),
                                color=color)

def plot_value_array(i, predictions_array, true_label):
  predictions_array, true_label = predictions_array, true_label[i]
  plt.grid(False)
  plt.xticks(range(10))
  plt.yticks([])
  thisplot = plt.bar(range(10), predictions_array, color=&quot;#777777&quot;)
  plt.ylim([0, 1])
  predicted_label = np.argmax(predictions_array)

  thisplot[predicted_label].set_color('red')
  thisplot[true_label].set_color('blue')
</code></pre>
<h3 id="验证预测结果">验证预测结果</h3>
<p>在模型经过训练后，您可以使用它对一些图像进行预测。</p>
<p>我们来看看第 0 个图像、预测结果和预测数组。正确的预测标签为蓝色，错误的预测标签为红色。数字表示预测标签的百分比（总计为 100）。</p>
<pre><code class="language-python">i = 0
plt.figure(figsize=(6,3))
plt.subplot(1,2,1)
plot_image(i, predictions[i], test_labels, test_images)
plt.subplot(1,2,2)
plot_value_array(i, predictions[i],  test_labels)
plt.show()
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://j-j-b-b.github.io//post-images/1652513700087.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">i = 12
plt.figure(figsize=(6,3))
plt.subplot(1,2,1)
plot_image(i, predictions[i], test_labels, test_images)
plt.subplot(1,2,2)
plot_value_array(i, predictions[i],  test_labels)
plt.show()
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://j-j-b-b.github.io//post-images/1652513707958.png" alt="" loading="lazy"></figure>
<p>让我们用模型的预测绘制几张图像。请注意，即使置信度很高，模型也可能出错。</p>
<pre><code class="language-python"># Plot the first X test images, their predicted labels, and the true labels.
# Color correct predictions in blue and incorrect predictions in red.
num_rows = 5
num_cols = 3
num_images = num_rows*num_cols
plt.figure(figsize=(2*2*num_cols, 2*num_rows))
for i in range(num_images):
  plt.subplot(num_rows, 2*num_cols, 2*i+1)
  plot_image(i, predictions[i], test_labels, test_images)
  plt.subplot(num_rows, 2*num_cols, 2*i+2)
  plot_value_array(i, predictions[i], test_labels)
plt.tight_layout()
plt.show()
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://j-j-b-b.github.io//post-images/1652513717055.png" alt="" loading="lazy"></figure>
<h2 id="使用训练好的模型">使用训练好的模型</h2>
<p>最后，使用训练好的模型对单个图像进行预测。</p>
<pre><code class="language-python"># Grab an image from the test dataset.
img = test_images[1]

print(img.shape)
</code></pre>
<blockquote>
<p>(28, 28)</p>
</blockquote>
<p><code>tf.keras</code> 模型经过了优化，可同时对一个<em>批</em>或一组样本进行预测。因此，即便您只使用一个图像，您也需要将其添加到列表中：</p>
<pre><code class="language-python"># Add the image to a batch where it's the only member.
img = (np.expand_dims(img,0))

print(img.shape)
</code></pre>
<blockquote>
<p>(1, 28, 28)</p>
</blockquote>
<p>现在预测这个图像的正确标签：</p>
<pre><code class="language-python">predictions_single = probability_model.predict(img)

print(predictions_single)
</code></pre>
<blockquote>
<p>[[5.2466153e-06 4.0142395e-15 9.9771106e-01 2.0327082e-11 1.8157117e-03  2.0388882e-09 4.6806235e-04 2.5122058e-18 5.3751874e-09 1.6207658e-17]]</p>
</blockquote>
<pre><code class="language-python">plot_value_array(1, predictions_single[0], test_labels)
_ = plt.xticks(range(10), class_names, rotation=45)
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://j-j-b-b.github.io//post-images/1652513726024.png" alt="" loading="lazy"></figure>
<p><code>keras.Model.predict</code> 会返回一组列表，每个列表对应一批数据中的每个图像。在批次中获取对我们（唯一）图像的预测：</p>
<pre><code class="language-python">np.argmax(predictions_single[0])
</code></pre>
<blockquote>
<p>2</p>
</blockquote>
<p>该模型会按照预期预测标签。</p>
<h1 id="电影评论文本分类">电影评论文本分类</h1>
<p>演示了从存储在磁盘上的纯文本文件开始的文本分类。您将训练一个二元分类器对 IMDB 数据集执行情感分析。在笔记本的最后，有一个练习供您尝试，您将在其中训练一个多类分类器来预测 Stack Overflow 上编程问题的标签。</p>
<pre><code class="language-python">import matplotlib.pyplot as plt
import os
import re
import shutil
import string
import tensorflow as tf
import tensorflow as tf
import keras

from keras import layers
from keras import losses
from keras import preprocessing
from tensorflow.keras.layers.experimental.preprocessing import TextVectorization
</code></pre>
<pre><code class="language-python">print(tf.__version__)
</code></pre>
<blockquote>
<p>2.8.0</p>
</blockquote>
<h2 id="情感分析">情感分析</h2>
<p>将使用 <a href="https://ai.stanford.edu/~amaas/data/sentiment/">Large Movie Review Dataset</a>，其中包含 <a href="https://www.imdb.com/">Internet Movie Database</a> 中的 50,000 条电影评论文本 。我们将这些评论分为两组，其中 25,000 条用于训练，另外 25,000 条用于测试。训练集和测试集是<em>均衡的</em>，也就是说其中包含相等数量的正面评价和负面评价。</p>
<h3 id="下载并探索-imdb-数据集">下载并探索 IMDB 数据集</h3>
<p>下载并提取数据集，然后浏览一下目录结构。</p>
<pre><code class="language-python">url = &quot;https://ai.stanford.edu/~amaas/data/sentiment/aclImdb_v1.tar.gz&quot;

dataset = tf.keras.utils.get_file(&quot;aclImdb_v1&quot;, url,
                                    untar=True, cache_dir='.',
                                    cache_subdir='')

dataset_dir = os.path.join(os.path.dirname(dataset), 'aclImdb')
</code></pre>
<pre><code class="language-python">os.listdir(dataset_dir)
</code></pre>
<blockquote>
<p>['imdb.vocab', 'test', 'README', 'train', 'imdbEr.txt']</p>
</blockquote>
<pre><code class="language-python">train_dir = os.path.join(dataset_dir, 'train')
os.listdir(train_dir)
</code></pre>
<blockquote>
<p>['urls_neg.txt', 'unsupBow.feat', 'urls_unsup.txt', 'urls_pos.txt', 'unsup', 'pos', 'neg', 'labeledBow.feat']</p>
</blockquote>
<p><code>aclImdb/train/pos</code> 和 <code>aclImdb/train/neg</code> 目录包含许多文本文件，每个文件都是一条电影评论。我们来看看其中的一条评论。</p>
<pre><code class="language-python">sample_file = os.path.join(train_dir, 'pos/1181_9.txt')
with open(sample_file) as f:
  print(f.read())
</code></pre>
<blockquote>
<p>Rachel Griffiths writes and directs this award winning short film. A heartwarming story about coping with grief and cherishing the memory of those we've loved and lost. Although, only 15 minutes long, Griffiths manages to capture so much emotion and truth onto film in the short space of time. Bud Tingwell gives a touching performance as Will, a widower struggling to cope with his wife's death. Will is confronted by the harsh reality of loneliness and helplessness as he proceeds to take care of Ruth's pet cow, Tulip. The film displays the grief and responsibility one feels for those they have loved and lost. Good cinematography, great direction, and superbly acted. It will bring tears to all those who have lost a loved one, and survived.</p>
</blockquote>
<h3 id="加载数据集">加载数据集</h3>
<p>接下来，您将从磁盘加载数据并将其准备为适合训练的格式。为此，您将使用有用的 <a href="https://tensorflow.google.cn/api_docs/python/tf/keras/preprocessing/text_dataset_from_directory">text_dataset_from_directory</a> 实用工具，它期望的目录结构如下所示。</p>
<pre><code>main_directory/
...class_a/
......a_text_1.txt
......a_text_2.txt
...class_b/
......b_text_1.txt
......b_text_2.txt
</code></pre>
<p>要准备用于二元分类的数据集，磁盘上需要有两个文件夹，分别对应于 <code>class_a</code> 和 <code>class_b</code>。这些将是正面和负面的电影评论，可以在 <code>aclImdb/train/pos</code> 和 <code>aclImdb/train/neg</code> 中找到。由于 IMDB 数据集包含其他文件夹，因此您需要在使用此实用工具之前将其移除。</p>
<pre><code class="language-python">remove_dir = os.path.join(train_dir, 'unsup')

shutil.rmtree(remove_dir)
</code></pre>
<p>接下来，您将使用 <code>text_dataset_from_directory</code> 实用工具创建带标签的 <code>tf.data.Dataset</code>。<a href="https://tensorflow.google.cn/guide/data">tf.data</a> 是一组强大的数据处理工具。</p>
<p>运行机器学习实验时，最佳做法是将数据集拆成三份：<a href="https://developers.google.com/machine-learning/glossary#training_set">训练</a>、<a href="https://developers.google.com/machine-learning/glossary#validation_set">验证</a> 和 <a href="https://developers.google.com/machine-learning/glossary#test-set">测试</a>。</p>
<p>IMDB 数据集已经分成训练集和测试集，但缺少验证集。我们来通过下面的 <code>validation_split</code> 参数，使用 80:20 拆分训练数据来创建验证集。</p>
<pre><code class="language-python">batch_size = 32
seed = 42

raw_train_ds = tf.keras.preprocessing.text_dataset_from_directory(
    'aclImdb/train', 
    batch_size=batch_size, 
    validation_split=0.2, 
    subset='training', 
    seed=seed)
</code></pre>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://j-j-b-b.github.io/post/java/">
                  <h3 class="post-title">
                    Java
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>




  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '9a17f8866b425882bb13',
        clientSecret: '6d39cd3760e10f894d724b88ca89585e6b4df85e',
        repo: 'j-j-b-b.github.io',
        owner: 'j-j-b-b',
        admin: ['j-j-b-b'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
